-- Copyright 2020-2023 The Defold Foundation
-- Copyright 2014-2020 King
-- Copyright 2009-2014 Ragnar Svensson, Christian Murray
-- Licensed under the Defold License version 1.0 (the "License"); you may not use
-- this file except in compliance with the License.
--
-- You may obtain a copy of the License, together with FAQs at
-- https://www.defold.com/license
--
-- Unless required by applicable law or agreed to in writing, software distributed
-- under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
-- CONDITIONS OF ANY KIND, either express or implied. See the License for the
-- specific language governing permissions and limitations under the License.

--
-- message constants
--
local MSG_CLEAR_COLOR =         hash("clear_color")
local MSG_WINDOW_RESIZED =      hash("window_resized")

-- CAMERA??? > temp solution, because I can't call go.*
local MSG_SET_VIEW_PROJ =       hash("set_view_projection")

-- CAMERA??? > shouldn't be here. just for prototyping
local camera = require("render.camera")

local function update_clear_color(self, color)
    if color then
        self.clear_buffers[render.BUFFER_COLOR_BIT] = color
    end
end

local function create_predicates(...)
    local arg = {...}
    local predicates = {}
    for _, predicate_name in pairs(arg) do
        predicates[predicate_name] = render.predicate({predicate_name})
    end
    return predicates
end

function init(self)
    self.predicates = create_predicates("tile", "gui", "text", "particle", "model")

    -- CAMERA??? > this function call is not needed. It will be done in the script module itself
    self.state = camera.update_state()
    self.color = vmath.vector4(0, 0, 0, 0)
    local color = self.color
    color.x = sys.get_config_number("render.clear_color_red", 0)
    color.y = sys.get_config_number("render.clear_color_green", 0)
    color.z = sys.get_config_number("render.clear_color_blue", 0)
    color.w = sys.get_config_number("render.clear_color_alpha", 0)
    self.clear_buffers = {
        [render.BUFFER_COLOR_BIT] = color,
        [render.BUFFER_DEPTH_BIT] = 1,
        [render.BUFFER_STENCIL_BIT] = 0
    }

    camera.use(camera.PROJ_STRETCH)
end

-- CAMERA??? > hack for better api
render.set_camera = camera.set_render

--[[
User APIs in render_script world.

I think user should be able to set what camera to render, something like
Render default camera:
render.camera()

Render one of predifined projections:
render.camera(camera.PROJ_WINDOW)
render.camera(camera.PROJ_*)

Render some specific camera:
render.camera("#camera")
or
render.camera(msg.url("something"))

It would be nice to have some way to specify camera for a frustrum as well
]]

function update(self)
    -- CAMERA??? > I think it should be hidden from user. if state isn't ready - don't call update, or something like that
    local state = self.state
    if not state then
        -- CAMERA??? > this function call is not needed. It will be done in the script module itself
        state = camera.update_state()
        if not state then
            return
        end
    end

    local predicates = self.predicates
    -- clear screen buffers
    --
    -- turn on depth_mask before `render.clear()` to clear it as well
    render.set_depth_mask(true)
    render.set_stencil_mask(0xff)
    render.clear(self.clear_buffers)

    -- setup camera view and projection
    --
    render.set_viewport(0, 0, state.window_width, state.window_height)

    render.set_camera()
    -- CAMERA??? > potential garbage generation here
    -- how to avoid it?
    local frustum = camera.get_frustum()

    -- set states used for all the world predicates
    render.set_blend_func(render.BLEND_SRC_ALPHA, render.BLEND_ONE_MINUS_SRC_ALPHA)
    render.enable_state(render.STATE_DEPTH_TEST)

    -- render `model` predicate for default 3D material
    --
    render.enable_state(render.STATE_CULL_FACE)
    render.draw(predicates.model, frustum)
    render.set_depth_mask(false)
    render.disable_state(render.STATE_CULL_FACE)

    -- render the other components: sprites, tilemaps, particles etc
    --
    render.enable_state(render.STATE_BLEND)
    render.draw(predicates.tile, frustum)
    render.draw(predicates.particle, frustum)
    render.disable_state(render.STATE_DEPTH_TEST)

    render.draw_debug3d()

    -- render GUI
    --

    render.set_camera(camera.PROJ_WINDOW)
    -- CAMERA??? > potential garbage generation here
    frustum = camera.get_frustum(camera.PROJ_WINDOW)

    render.enable_state(render.STATE_STENCIL_TEST)
    render.draw(predicates.gui, frustum)
    render.draw(predicates.text, frustum)
    render.disable_state(render.STATE_STENCIL_TEST)
    render.disable_state(render.STATE_BLEND)
end

function on_message(self, message_id, message)
    if message_id == MSG_CLEAR_COLOR then
        update_clear_color(self, message.color)
    elseif message_id == MSG_WINDOW_RESIZED then
    -- CAMERA??? > should be done inside the engine
        self.state = camera.update_state()
    -- CAMERA??? > temp solution, because I can't call go.*
    elseif message_id == MSG_SET_VIEW_PROJ then
        camera.hacky_camera_update(message.view or vmath.matrix4(), message.projection or vmath.matrix4())
    end
end
